"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Log = exports.secondverboseTag = exports.verboseTag = exports.INDENT_TOKEN = void 0;
/* eslint-disable no-console */
const chalk_1 = require("./chalk");
const is_color_supported_1 = require("./chalk/is-color-supported");
const log_level_1 = require("./log-level");
const repro_1 = require("./repro");
const truthy_1 = require("./truthy");
exports.INDENT_TOKEN = chalk_1.chalk.gray('â”‚');
const verboseTag = (str) => {
    return (0, is_color_supported_1.isColorSupported)() ? chalk_1.chalk.bgBlack(` ${str} `) : `[${str}]`;
};
exports.verboseTag = verboseTag;
const secondverboseTag = (str) => {
    return (0, is_color_supported_1.isColorSupported)() ? chalk_1.chalk.bgWhite(` ${str} `) : `[${str}]`;
};
exports.secondverboseTag = secondverboseTag;
exports.Log = {
    trace: (options, ...args) => {
        (0, repro_1.writeInRepro)('trace', ...args);
        if ((0, log_level_1.isEqualOrBelowLogLevel)(options.logLevel, 'trace')) {
            if (args.length === 0) {
                // Lambda will print "undefined" otherwise
                return process.stdout.write('\n');
            }
            return console.log(...[
                options.indent ? exports.INDENT_TOKEN : null,
                options.tag ? (0, exports.verboseTag)(options.tag) : null,
            ]
                .filter(truthy_1.truthy)
                .concat(args.map((a) => chalk_1.chalk.gray(a))));
        }
    },
    verbose: (options, ...args) => {
        (0, repro_1.writeInRepro)('verbose', ...args);
        if ((0, log_level_1.isEqualOrBelowLogLevel)(options.logLevel, 'verbose')) {
            if (args.length === 0) {
                // Lambda will print "undefined" otherwise
                return process.stdout.write('\n');
            }
            return console.log(...[
                options.indent ? exports.INDENT_TOKEN : null,
                options.tag ? (0, exports.verboseTag)(options.tag) : null,
            ]
                .filter(truthy_1.truthy)
                .concat(args.map((a) => chalk_1.chalk.gray(a))));
        }
    },
    info: (options, ...args) => {
        (0, repro_1.writeInRepro)('info', ...args);
        if ((0, log_level_1.isEqualOrBelowLogLevel)(options.logLevel, 'info')) {
            if (args.length === 0) {
                // Lambda will print "undefined" otherwise
                return process.stdout.write('\n');
            }
            return console.log(...[options.indent ? exports.INDENT_TOKEN : null]
                .filter(truthy_1.truthy)
                .concat(args !== null && args !== void 0 ? args : []));
        }
    },
    warn: (options, ...args) => {
        (0, repro_1.writeInRepro)('warn', ...args);
        if ((0, log_level_1.isEqualOrBelowLogLevel)(options.logLevel, 'warn')) {
            if (args.length === 0) {
                // Lambda will print "undefined" otherwise
                return process.stdout.write('\n');
            }
            return console.warn(...[options.indent ? chalk_1.chalk.yellow(exports.INDENT_TOKEN) : null]
                .filter(truthy_1.truthy)
                .concat(args.map((a) => chalk_1.chalk.yellow(a))));
        }
    },
    error: (options, ...args) => {
        (0, repro_1.writeInRepro)('error', ...args);
        if ((0, log_level_1.isEqualOrBelowLogLevel)(options.logLevel, 'error')) {
            if (args.length === 0) {
                // Lambda will print "undefined" otherwise
                return process.stdout.write('\n');
            }
            return console.error(...[
                options.indent ? exports.INDENT_TOKEN : null,
                options.tag ? (0, exports.verboseTag)(options.tag) : null,
            ]
                .filter(truthy_1.truthy)
                .concat(args.map((a) => chalk_1.chalk.red(a))));
        }
    },
};
