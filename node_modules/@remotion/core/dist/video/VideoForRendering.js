"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoForRendering = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const defer_ready_1 = require("../defer-ready");
const use_frame_1 = require("../use-frame");
const use_video_config_1 = require("../use-video-config");
const VideoForRendering = (props) => {
    const [metadataLoaded, setMetadataLoaded] = react_1.useState(false);
    const [currentFrameSet, setCurrentFrameSet] = react_1.useState(false);
    const [handle] = react_1.useState(() => {
        return defer_ready_1.deferRender();
    });
    const currentFrame = use_frame_1.useCurrentFrame();
    const videoConfig = use_video_config_1.useVideoConfig();
    const videoRef = react_1.useRef(null);
    if (!videoConfig) {
        throw new Error('No video config found');
    }
    const frameInSeconds = react_1.useMemo(() => currentFrame / videoConfig.fps, [
        currentFrame,
        videoConfig.fps,
    ]);
    const setFrame = react_1.useCallback(() => {
        if (!videoRef.current) {
            return;
        }
        videoRef.current.currentTime = frameInSeconds;
        videoRef.current.addEventListener('seeked', () => {
            defer_ready_1.readyToRender(handle);
        }, { once: true });
        setInterval(() => {
            setCurrentFrameSet(true);
        }, 0);
    }, [frameInSeconds, handle]);
    const onMetadataLoad = react_1.useCallback(() => {
        setMetadataLoaded(true);
    }, []);
    react_1.useEffect(() => {
        if (metadataLoaded) {
            setFrame();
        }
    }, [metadataLoaded, currentFrameSet, setFrame]);
    react_1.useEffect(() => {
        if (!videoRef.current) {
            return;
        }
        if (metadataLoaded) {
            setFrame();
            return;
        }
        const { current } = videoRef;
        current.addEventListener('loadedmetadata', onMetadataLoad);
        return () => {
            current.removeEventListener('loadedmetadata', onMetadataLoad);
        };
    }, [currentFrame, metadataLoaded, onMetadataLoad, setFrame, videoConfig.fps]);
    const onSetReadyState = react_1.useCallback(() => {
        if (!videoRef.current) {
            throw Error('No vide ref');
        }
        if (videoRef.current.readyState === 4) {
            setFrame();
        }
    }, [setFrame]);
    react_1.useEffect(() => {
        if (!videoRef.current) {
            return;
        }
        const { current } = videoRef;
        current.addEventListener('loadeddata', onSetReadyState);
        return () => {
            current.removeEventListener('loadeddata', onSetReadyState);
        };
    });
    return jsx_runtime_1.jsx("video", Object.assign({ ref: videoRef }, props), void 0);
};
exports.VideoForRendering = VideoForRendering;
//# sourceMappingURL=VideoForRendering.js.map