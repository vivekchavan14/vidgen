"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFrames = void 0;
const media_parser_1 = require("@remotion/media-parser");
const worker_1 = require("@remotion/media-parser/worker");
const create_video_decoder_1 = require("./create-video-decoder");
const with_resolvers_1 = require("./create/with-resolvers");
const internalExtractFrames = ({ src, onFrame, signal, timestampsInSeconds, acknowledgeRemotionLicense, logLevel, }) => {
    const controller = (0, media_parser_1.mediaParserController)();
    const expectedFrames = [];
    const resolvers = (0, with_resolvers_1.withResolvers)();
    const abortListener = () => {
        controller.abort();
        resolvers.reject(new media_parser_1.MediaParserAbortError('Aborted by user'));
    };
    signal?.addEventListener('abort', abortListener, { once: true });
    let dur = null;
    (0, worker_1.parseMediaOnWebWorker)({
        src: new URL(src, window.location.href),
        acknowledgeRemotionLicense,
        controller,
        logLevel,
        onDurationInSeconds(durationInSeconds) {
            dur = durationInSeconds;
        },
        onVideoTrack: async ({ track }) => {
            const timestampTargetsUnsorted = typeof timestampsInSeconds === 'function'
                ? await timestampsInSeconds({
                    track,
                    durationInSeconds: dur,
                })
                : timestampsInSeconds;
            const timestampTargets = timestampTargetsUnsorted.sort((a, b) => a - b);
            controller.seek(timestampTargets[0]);
            const decoder = (0, create_video_decoder_1.createVideoDecoder)({
                onFrame: (frame) => {
                    if (frame.timestamp >= expectedFrames[0] - 1) {
                        expectedFrames.shift();
                        onFrame(frame);
                    }
                    else {
                        frame.close();
                    }
                },
                onError: (e) => {
                    controller.abort();
                    try {
                        decoder.close();
                    }
                    catch { }
                    resolvers.reject(e);
                },
                track,
            });
            const queued = [];
            const doProcess = async () => {
                expectedFrames.push(timestampTargets.shift() * media_parser_1.WEBCODECS_TIMESCALE);
                while (queued.length > 0) {
                    const sam = queued.shift();
                    await decoder.waitForQueueToBeLessThan(10);
                    await decoder.decode(sam);
                }
            };
            return async (sample) => {
                const nextTimestampWeWant = timestampTargets[0];
                if (sample.type === 'key') {
                    await decoder.flush();
                    queued.length = 0;
                }
                queued.push(sample);
                if (sample.timestamp >=
                    timestampTargets[timestampTargets.length - 1] * media_parser_1.WEBCODECS_TIMESCALE) {
                    await doProcess();
                    await decoder.flush();
                    controller.abort();
                    return;
                }
                if (nextTimestampWeWant === undefined) {
                    throw new Error('this should not happen');
                }
                if (sample.timestamp >= nextTimestampWeWant * media_parser_1.WEBCODECS_TIMESCALE) {
                    await doProcess();
                    if (timestampTargets.length === 0) {
                        await decoder.flush();
                        controller.abort();
                    }
                }
                return async () => {
                    await decoder.flush();
                };
            };
        },
    })
        .then(() => {
        resolvers.resolve();
    })
        .catch((e) => {
        if (!(0, media_parser_1.hasBeenAborted)(e)) {
            resolvers.reject(e);
        }
        else {
            resolvers.resolve();
        }
    })
        .finally(() => {
        signal?.removeEventListener('abort', abortListener);
    });
    return resolvers.promise;
};
const extractFrames = (options) => {
    return internalExtractFrames({
        ...options,
        signal: options.signal ?? null,
        acknowledgeRemotionLicense: options.acknowledgeRemotionLicense ?? false,
        logLevel: options.logLevel ?? 'info',
    });
};
exports.extractFrames = extractFrames;
