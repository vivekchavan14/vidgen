import type { _InternalEbmlValue, MediaParserInternalTypes } from '@remotion/media-parser';
import { MediaParserInternals } from '@remotion/media-parser';
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
export declare const getIdForName: (name: string) => EbmlMapKey;
export declare const combineUint8Arrays: (arrays: Uint8Array[]) => Uint8Array<ArrayBufferLike>;
export type OffsetAndChildren = {
    offset: number;
    children: OffsetAndChildren[];
    field: keyof typeof MediaParserInternals.matroskaElements;
};
export declare const incrementOffsetAndChildren: (offset: OffsetAndChildren, increment: number) => OffsetAndChildren;
export declare const matroskaToHex: (matrId: (typeof MediaParserInternals.matroskaElements)[keyof typeof MediaParserInternals.matroskaElements]) => Uint8Array<ArrayBufferLike>;
export type BytesAndOffset = {
    bytes: Uint8Array;
    offsets: OffsetAndChildren;
};
export type EbmlValueOrUint8Array<T extends MediaParserInternalTypes['Ebml']> = Uint8Array | _InternalEbmlValue<T, PossibleEbmlOrUint8Array>;
export type EbmlParsedOrUint8Array<T extends MediaParserInternalTypes['Ebml']> = {
    type: T['name'];
    value: EbmlValueOrUint8Array<T>;
    minVintWidth: number | null;
};
export declare const measureEBMLVarInt: (value: number) => 1 | 2 | 4 | 3 | 5 | 6;
export declare const getVariableInt: (value: number, minWidth: number | null) => Uint8Array<ArrayBuffer>;
export declare const makeMatroskaBytes: (fields: PossibleEbmlOrUint8Array) => BytesAndOffset;
export type PossibleEbmlOrUint8Array = Prettify<{
    [key in keyof typeof MediaParserInternals.ebmlMap]: EbmlParsedOrUint8Array<(typeof MediaParserInternals.ebmlMap)[key]>;
}[keyof typeof MediaParserInternals.ebmlMap]> | BytesAndOffset;
export type EbmlMapKey = keyof typeof MediaParserInternals.ebmlMap;
export declare const padMatroskaBytes: (fields: PossibleEbmlOrUint8Array, totalLength: number) => BytesAndOffset[];
export declare function serializeUint16(value: number): Uint8Array;
export {};
