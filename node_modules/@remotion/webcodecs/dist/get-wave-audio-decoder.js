"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWaveAudioDecoder = void 0;
const getBytesPerSample = (sampleFormat) => {
    if (sampleFormat === 's16') {
        return 2;
    }
    if (sampleFormat === 's32') {
        return 4;
    }
    if (sampleFormat === 'f32') {
        return 4;
    }
    if (sampleFormat === 'u8') {
        return 1;
    }
    if (sampleFormat === 'f32-planar') {
        return 4;
    }
    if (sampleFormat === 's16-planar') {
        return 2;
    }
    if (sampleFormat === 's32-planar') {
        return 4;
    }
    if (sampleFormat === 'u8-planar') {
        return 1;
    }
    throw new Error(`Unsupported sample format: ${sampleFormat}`);
};
const getAudioData = (audioSample) => {
    if (audioSample instanceof EncodedAudioChunk) {
        const data = new Uint8Array(audioSample.byteLength);
        audioSample.copyTo(data);
        return data;
    }
    return audioSample.data;
};
const getWaveAudioDecoder = ({ onFrame, config, sampleFormat, ioSynchronizer, onError, }) => {
    const processSample = async (audioSample) => {
        const bytesPerSample = getBytesPerSample(sampleFormat);
        const data = getAudioData(audioSample);
        const audioData = new AudioData({
            data,
            format: sampleFormat,
            numberOfChannels: config.numberOfChannels,
            numberOfFrames: data.byteLength / bytesPerSample / config.numberOfChannels,
            sampleRate: config.sampleRate,
            timestamp: audioSample.timestamp,
        });
        try {
            await onFrame(audioData);
        }
        catch (err) {
            audioData.close();
            onError(err);
        }
    };
    let lastReset = null;
    let mostRecentSampleInput = null;
    return {
        close() {
            return Promise.resolve();
        },
        decode(audioSample) {
            mostRecentSampleInput = audioSample.timestamp;
            return processSample(audioSample);
        },
        flush: () => Promise.resolve(),
        waitForQueueToBeLessThan: ioSynchronizer.waitForQueueSize,
        reset: () => {
            lastReset = Date.now();
        },
        checkReset: () => ({
            wasReset: () => lastReset !== null && lastReset > Date.now(),
        }),
        getMostRecentSampleInput: () => mostRecentSampleInput,
    };
};
exports.getWaveAudioDecoder = getWaveAudioDecoder;
