"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoSelectWriter = void 0;
const web_fs_1 = require("./writers/web-fs");
const with_resolvers_1 = require("./create/with-resolvers");
const log_1 = require("./log");
const buffer_1 = require("./writers/buffer");
const autoSelectWriter = async (writer, logLevel) => {
    if (writer) {
        log_1.Log.verbose(logLevel, 'Using writer provided by user');
        return writer;
    }
    log_1.Log.verbose(logLevel, 'Determining best writer');
    const hasNavigator = typeof navigator !== 'undefined';
    if (!hasNavigator) {
        log_1.Log.verbose(logLevel, 'No navigator API detected, using buffer writer');
        return buffer_1.bufferWriter;
    }
    // Check if we're offline using the navigator API
    const isOffline = !navigator.onLine;
    if (isOffline) {
        log_1.Log.verbose(logLevel, 'Offline mode detected, using buffer writer');
        return buffer_1.bufferWriter;
    }
    try {
        const { promise: timeout, reject, resolve } = (0, with_resolvers_1.withResolvers)();
        const time = setTimeout(() => reject(new Error('WebFS check timeout')), 2000);
        const webFsSupported = await Promise.race([(0, web_fs_1.canUseWebFsWriter)(), timeout]);
        resolve();
        clearTimeout(time);
        if (webFsSupported) {
            log_1.Log.verbose(logLevel, 'Using WebFS writer because it is supported');
            return web_fs_1.webFsWriter;
        }
    }
    catch (err) {
        log_1.Log.verbose(logLevel, `WebFS check failed: ${err}. Falling back to buffer writer`);
    }
    log_1.Log.verbose(logLevel, 'Using buffer writer because WebFS writer is not supported or unavailable');
    return buffer_1.bufferWriter;
};
exports.autoSelectWriter = autoSelectWriter;
