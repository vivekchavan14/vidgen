"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cachedSamplePositionsState = exports.calculateFlatSamples = void 0;
const are_samples_complete_1 = require("../../containers/iso-base-media/are-samples-complete");
const get_sample_positions_from_track_1 = require("../../containers/iso-base-media/get-sample-positions-from-track");
const traversal_1 = require("../../containers/iso-base-media/traversal");
const get_tracks_1 = require("../../get-tracks");
const precomputed_tfra_1 = require("./precomputed-tfra");
const calculateFlatSamples = ({ state, mediaSectionStart, }) => {
    var _a, _b;
    const tracks = (0, get_tracks_1.getTracks)(state, true);
    const moofBoxes = (0, traversal_1.getMoofBoxes)(state.structure.getIsoStructure().boxes);
    const tfraBoxes = (0, precomputed_tfra_1.deduplicateTfraBoxesByOffset)([
        ...state.iso.tfra.getTfraBoxes(),
        ...(0, traversal_1.getTfraBoxes)(state.structure.getIsoStructure().boxes),
    ]);
    const moofComplete = (0, are_samples_complete_1.areSamplesComplete)({ moofBoxes, tfraBoxes });
    const relevantMoofBox = moofBoxes.find((moofBox) => moofBox.offset + moofBox.size + 8 === mediaSectionStart);
    if (moofBoxes.length > 0 && !relevantMoofBox) {
        throw new Error('No relevant moof box found');
    }
    const moov = (0, traversal_1.getMoovBoxFromState)({
        structureState: state.structure,
        isoState: state.iso,
        mp4HeaderSegment: (_b = (_a = state.m3uPlaylistContext) === null || _a === void 0 ? void 0 : _a.mp4HeaderSegment) !== null && _b !== void 0 ? _b : null,
        mayUsePrecomputed: true,
    });
    if (!moov) {
        throw new Error('No moov box found');
    }
    const flatSamples = tracks.map((track) => {
        const trakBox = (0, traversal_1.getTrakBoxByTrackId)(moov, track.trackId);
        if (!trakBox) {
            throw new Error('No trak box found');
        }
        const { samplePositions } = (0, get_sample_positions_from_track_1.getSamplePositionsFromTrack)({
            trakBox,
            moofBoxes: relevantMoofBox ? [relevantMoofBox] : [],
            moofComplete,
            trexBoxes: (0, traversal_1.getTrexBoxes)(moov),
        });
        return samplePositions.map((samplePosition) => {
            return {
                track,
                samplePosition,
            };
        });
    });
    return flatSamples;
};
exports.calculateFlatSamples = calculateFlatSamples;
const cachedSamplePositionsState = () => {
    const cachedForMdatStart = {};
    const jumpMarksForMdatStart = {};
    return {
        getSamples: (mdatStart) => {
            var _a;
            return (_a = cachedForMdatStart[mdatStart]) !== null && _a !== void 0 ? _a : null;
        },
        setSamples: (mdatStart, samples) => {
            cachedForMdatStart[mdatStart] = samples;
        },
        setJumpMarks: (mdatStart, marks) => {
            jumpMarksForMdatStart[mdatStart] = marks;
        },
        getJumpMarks: (mdatStart) => {
            return jumpMarksForMdatStart[mdatStart];
        },
    };
};
exports.cachedSamplePositionsState = cachedSamplePositionsState;
